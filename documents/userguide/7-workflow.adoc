# Workflow Service

Piazza provides the ability for users to define and send _Events_, representing some "thing" that has happened. These Events can be issued either from within Piazza or by an external client. Piazza also allows for users to define _Triggers_, containing both an event-condition and an action: when the condition is met, the action is performed. Taken together, _EventTypes_, _Events_, and _Triggers_ can be used to define _workflows_.

NOTE: By design, Events and Triggers are fairly primitive, low-level constructs. As Piazza matures, richer support for defining workflows may be added.

## The EventType

The user (or some service) first defines an _EventType_ which is the "schema" for the Events that the user will be generating. The _EventType_ object is sent in a `POST` request to the `/eventType` endpoint and contains contains a unique `name` (string) and a mapping describing the EventType's parameters. For example:

[source,json]
----
{
    "name": "testevent-1468849135",
    "mapping": {
        "filename": "string",
        "code":     "string",
        "severity": "integer"
    }
}
----

The `name` must be unique across all event types in the system.

The available data types are `string`, `boolean`, `integer`, `double`, `date`, `float`, `byte`, `short`, and `long`. By no coincidence, these are the basic types that Elasticsearch supports.

The following script shows an example of registering an EventType. Run it using:

    $ ./7-eventtype.sh

link:scripts/7-eventtype.sh[7-eventtype.sh]
[source,bash]
----
include::scripts/7-eventtype.sh[tags=public]
----


## The Trigger

The user then defines a _Trigger_ which defines what action is to be taken when a specific event occurs. The _Trigger_ is sent as a `POST` request to the `/trigger` endpoint and contains four parts. The `condition` defines what type of event is to be watched for and what the specific parameters of that event should be, expressed using Elasticsearch DSL query syntax against the parameters in the event type. The `job` defines what action is to be taken, expressed as using Gateway/Dispatcher-style syntax. The `title` is a memorable string for describing what the _Trigger_ is meant to do, and the `enabled` field determines if the _Trigger_ should be listening for Events in order to send Alerts. For example:

[source,json]
----
{
    "title": "High Severity",
    "enabled": true,
    "condition": {
        "eventTypeIds": ["98fc25e8-bd97-4444-a972-c06aa0f0edf1"],
        "query": {
            "query": {
                "bool": {
                    "must": [
                        { "match": {"severity": 5} },
                        { "match": {"code": "PHONE"} }
                    ]
                }
            }
        }
    },
    "job": {
        "jobType": {
            "type": "execute-service",
            "data": {
                "serviceId": "a2898bcb-2646-4ffd-9da7-2308cb7e77d7",
                "dataInputs": {
                    "test": {
                        "content": "{ \"log\": \"Received code $code with severity $severity\" }",
                        "type": "body",
                        "mimeType": "application/json"
                    }
                },
                "dataOutput": [ {
                    "mimeType":"image/tiff",
                    "type":"raster"
                } ]
            }
        }
    }
}
----

For details on constructing valid Elasticsearch DSL queries, see the <<Elasticsearch Query Syntax>> section.

In this example, the job will be executed only when our "test" event occurs with the `severity` equal to `5` and the `code` equal to `"PHONE"`.

It's important to note that the "job" field uses substitution by replacing all instances of `$field` (where `field` is the name of a JSON field in the EventType `mapping` (and thus subsequently in the Event's `data` field)) with the `field` in the event that sets off the Trigger. This substitution occurs in all of the fields in `job`, so it is important to be conscious of this.

Pass the following script an `eventTypeId`, and it will create a generic Trigger for the EventType associated with that `eventTypeId`:

    $ ./7-trigger.sh {{eventTypeId}}

link:scripts/7-trigger.sh[7-trigger.sh]
[source,bash]
----
include::scripts/7-trigger.sh[tags=public]
----


## The Event

The user may generate an _Event_ of that _EventType_ to indicate some interesting condition has occurred. The _Event_ object is sent as a `POST` request to the `/event` endpoint and contains the `eventTypeId` of the _EventType_, and the parameters of the event. For example:

[source,json]
----
{
    "eventTypeId": "98fc25e8-bd97-4444-a972-c06aa0f0edf1",
    "data": {
        "filename": "dataset-c",
        "severity": 5,
        "code": "PHONE"
    }
}
----

In addition, an _Event_ can specify a `cronSchedule` field, which alters the mechanics of the _Event_ slightly. The `cronSchedule` field specifies a schedule at which to repeat the specified event. This schedule is created as a cron expression. Users who are unfamiliar with cron expressions should check the man pages for cron, either via `man cron`, `man crontab`, or by searching online for cron related resources. Some helpful resources might include http://www.cronmaker.com/[cronmaker.com] and http://crontab.guru/[crontab.guru]. However, it is critical to note that the cron specification being used in our implementation is spelled out in https://github.com/robfig/cron/blob/master/doc.go, with the crucial difference being that our cron flavor designates the first asterisk as the *seconds* field. This means:

* `"cronSchedule": "* * * * * *"` - send the event every second;
* `"cronSchedule": "30 * * * * *"` - send the event every minute at the 30 second mark;
* `"cronSchedule": "* 30 * * * *"` - send the event every hour at the 30 minute mark, etc.

For reference, the 6 stars in the cronSchedule stand for:

*seconds | minutes | hours | day of month | month | day of week*

In some cron implementations, the rightmost asterisks can be omitted from the notation; this is not the case with the particular flavor of cron we are using.

Additionally, cronSchedules can be spelled out using shorthand notation. These shorthands include:

.Shorthands
|===
| Entry | Description | Equivalent To

| `@yearly` (or `@annually`)
| Run once a year, midnight, Jan. 1st
| `0 0 0 1 1 *`

| `@monthly`
| Run once a month, midnight, first of month
| `0 0 0 1 * *`

| `@weekly`
| Run once a week, midnight on Sunday
| `0 0 0 * * 0`

| `@daily` (or `@midnight`)
| Run once a day, midnight
| `0 0 0 * * *`

| `@hourly`
| Run once an hour, beginning of hour
| `0 0 * * * *`
|===

Lastly, cronSchedule can be specified using the `@every duration` notation, where duration is replaced by a Golang parsable https://golang.org/pkg/time/#Duration[time.Duration]. Examples include:

* `"cronSchedule": "@every 1h30m10s"` - send event every 1 hour, 30 minutes, 10 seconds
* `"cronSchedule": "@every 30s"` - send event every 30 seconds
* `"cronSchedule": "@every 5m"` - send event every 5 minutes

It is crucial to understand that an *Event that is sent with a cronSchedule does not trigger the system in the same way that a typical Event does*. Rather, it sets up a recurring Event that will be sent according to the schedule specified. If you require both an Event to be sent now as well as on a particular schedule, it is wise to send both a non-repeating Event and a repeating Event.

In order to stop repeating events, DELETE the initial repeating event by eventId.

    DELETE /event/{{eventId}}

The following script POSTs an event with an eventTypeId passed in by the user:

    $ ./7-event.sh {{eventTypeId}}

link:scripts/7-event.sh[7-event.sh]
[source,bash]
----
include::scripts/7-event.sh[tags=public]
----


## The Alert

Whenever the condition of a _Trigger_ is met, the system will create an _Alert_ object. The user can GET a list of Alerts from the `/alert` endpoint. The _Alert_ object contains the ids of the _Trigger_ that was hit and the _Event_ which caused it. It also contains a generated `alertId`. For example:

[source,json]
----
{
  "statusCode": 200,
  "type": "alert-list",
  "data": [
    {
      "alertId": "58d1ad21-75d0-4ee4-8429-c687b9249cc5",
      "triggerId": "170619d6-8f4e-4dc4-bcb6-8b0862e0138f",
      "eventId": "baa98fc7-f282-4caf-b35d-c2050eca010c",
      "jobId": "ab62ae7e-432b-4b61-a831-4a80b6ce836e",
      "createdBy": "",
      "createdOn": "2016-07-18T13:41:28.571761514Z"
    }
  ],
  "pagination": {
    "count": 1,
    "page": 0,
    "perPage": 10,
    "sortBy": "alertId",
    "order": "asc"
  }
}
----

The following script gets the list of Alerts currently in the Piazza system, with default pagination and per_page settings:

    $ ./7-get-alerts.sh

link:scripts/7-get-alerts.sh[7-get-alerts.sh]
[source,bash]
----
include::scripts/7-get-alerts.sh[tags=public]
----

The query parameter `?triggerId=id` is provided to allow the list to be filtered to only Alerts set off by a specified Trigger.
