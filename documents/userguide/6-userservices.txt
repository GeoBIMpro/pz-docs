# User Services

Piazza allows users to discover, manage and invoke external web services known as *User Services*.
A user service is defined as a set of web technologies used for exchanging data between software
applications over a network, such as the Internet. Web technologies such as HTTP, JSON and XML
are used because they allow for data to be exchanged in a platform-independent manner.

Using Piazza, users can combine user services to perform complex tasks automatically such as
orthorectifying an image, running statistical analysis on the image and then notifying an analyst
that image has finished processing and is ready for review.

Piazza provides a RESTful API allowing users to perform user service management activities such as:

. Register user services for search/discovery (See the <<Search>> section for details)
. Update information on the web service (e.g. URL, name, version and other metadata)
. Remove a web service from the registry
. View details about registered web services
. Execute a registered user service
. Combine user services to perform various tasks (See the <<Workflow Service>> section for
    details)

While Piazzaâ€™s overall all goal is to provide users with the ability to register and use existing
RESTful user services, to work best with Piazza, there are some guidelines on writing user
services. See the <<How to Write Your Own Services>> section for details on how to write user
services to be used by Piazza.

NOTE: Piazza currently requires you have the user service instance deployed at a public URL. In
    the future, the user service will be a deployable container, so Piazza can scale the number of
    instances needed.

The following sections will use a "Hello World" service. This service basically just says hello.
It is deployed in our cloud for testing services.

## Registration

A user service must be _registered_ with Piazza before it can invoked or discovered by Piazza
users. To register a user service with Piazza, the client sends to Piazza a JSON payload with the
URL of the service, a description of its parameters, and other metadata.

### Hello Example registered with GET method.

Registration Service registered by POSTing to service endpoint.
A script registering the following service and returning the service ID can be found
link:scripts/6-register.sh[here].

[source,json]
----
{
    "url": "http://pzsvc-hello.venicegeo.io/",
    "contractUrl": "http://helloContract",
    "serviceId": "",
    "resourceMetadata": {
        "name": "pzsvc-hello service",
        "description": "Hello World Example",
        "method" : "GET"
    }
}
----

* https://pz-gateway.venicegeo.io/service is the endpoint for registering the service.
* Inside the curly brackets is a JSON object describing the service.

** The url field is the URL for invoking the service.
** The contractUrl is an optional field containing additional detail information about the service.
** The serviceId will be filled in by Piazza.
** The resourceMetadata fields has 3 subfields with the name, description of the service and the
invocation method for the service.

NOTE: The description should be entered with some care because it will enable other users to search
    for your service.

Return Value
[source,json]
----
{
    "type": "service",
    "serviceId": "a04e274c-f929-4507-9174-dd24722d89d9"
}
----
The serviceId field should be noted since it will be used in invoking the service.

Note that the method field can be changed as needed, depending on the intended operation performed
by the service.

## Invocation

### Hello Example invoked with GET method.

The service is invoked by POSTing to the pz-gateway job endpoint
https://pz-gateway.venicegeo.io/v2/job. A script that does this can be found at
link:scripts/6-execute-get.sh[6-execute-get.sh]. Provide the serviceId returned by the register
script as the first argument to the script.

[source,json]
----
{
    "type": "execute-service",
    "data": {
        "serviceId": "a04e274c-f929-4507-9174-dd24722d89d9",
        "dataInputs": {},
        "dataOutput": [{ "mimeType":"application/json", "type":"text" }]
    }
}
----

The serviceId is set to the return value from registering the service. In this example, no
dataInputs are specified. For dataOutput, the mimeType refers to the mimeType of the service
output. The type refers to how the output will be stored until retrieved (see below).

The return value is not the result of the service call. The execute-service call creates a job and
returns the id of that job.

[source,json]
----
{
  "type": "job",
  "jobId": "e42a2ea3-2f16-4ee2-bf74-fa7c792c0847"
}
----

### Hello Example invoked with POST method.

When executing a service that requires a POST body for input, the body message is specified in the
content field, the type is "body" and the mimeType has to be specified. Getting the jobId is
exactly the same as in the GET case.

[source,json]
----
{
  "type": "execute-service",
  "data": {
    "serviceId": {{serviceId}}
    "dataInputs": {
      "test" : {
        "content" : "{ \"name\": \"Fred\", \"count\": 4 }",
        "type" : "body",
        "mimeType" : "application/json"
      }
    },
    "dataOutput": [{ "mimeType":"application/json", "type":"text" }]
}
----

## Getting Status and Results

The status is returned by sending a GET message to `https://pz-gateway.venicegeo.io/job/{{jobId}}`
where jobId is the id returned when executing the service. On success the resulting status is

[source,json]
----
{
  "type": "status",
  "jobId": "e42a2ea3-2f16-4ee2-bf74-fa7c792c0847",
  "result": {
    "type": "data",
    "dataId": "b92e7cc5-310e-4a72-a4ab-21661b58d601"
  },
  "status": "Success",
  "jobType": "execute-service",
  "submittedBy": "UNAUTHENTICATED",
  "progress": {}
}
----

A script that checks the status of the job can be found at
link:scripts/6-get-status.sh[6-get-status.sh]. The script takes the jobId returned from the
6-execute-get.sh script as it's only argument.

Finally, the actual result is returned by sending a GET message to
`https://pz-gateway.venicegeo.io/data/{{dataId}}` where the dataId is from the result.dataId field
of the returned status. In this case the result is text.

[source,json]
----
{
  "type": "data",
  "data": {
    "dataId": "b92e7cc5-310e-4a72-a4ab-21661b58d601",
    "dataType": {
      "type": "text",
      "content": "Hi. I'm pzsvc-hello."
    }
  }
}
----

Run the link:scripts/6-get-result.sh[6-get-result.sh] script to check the result of the previous
job. This script also takes a single argument: the dataId returned by the previous script.

## How to Write Your Own Services

*TODO*
