# Workflow Service

Piazza provides the ability for users to define and send _events_, representing some "thing" that
has happened. These events can be issued either from within Piazza or by an external client. Piazza
also allows for users to define _triggers_, containing both an event-condition and an action: when
the condition is met, the action is performed. Taken together, _eventtypes_, _events_, and
_triggers_ can be used to define _workflows_. A script that sets up the workflow described in this
section can be found link:scripts/7-example.sh[here].

NOTE: By design, events and triggers are fairly primitive, low-level constructs. As Piazza matures,
    richer support for defining workflows may be added.

## The EventType

The user (or some service) first defines an _EventType_ which is the "schema" for the events that
the user will be generating. The _EventType_ object is POSTed to `/eventType` and contains
contains a _name_ (string) and a map describing the event type's parameters. It also contains a
system-generated ID. For example:

[source,json]
----
{
    "id": "17de4",
    "name": "USDataFound",     # short, id-like string
    "mapping": {
        "ItemId": "string",    # the uuid of the bad data
        "Severity": "integer", # level of offense, 1..5
        "Problem": "string"    # nature of the issue, e.g. US bbox, US phone number, etc
    }
}
----

The available data types are `string`, `boolean`, `integer`, `double`, `date`, `float`, `byte`,
`short`, and `long`. (By no coincidence, these are the basic types that Elasticsearch supports.)


## The Trigger

The user then defines a _Trigger_ which defines what action is to be taken when a specific event
occurs. The _Trigger_ is POSTed to `/trigger` and contains two parts, the _Condition_ and the
_Job_. The _Condition_ defines what type of event is to be watched for and what the specific
parameters of that event should be, expressed using Elasticsearch DSL query syntax against the
parameters in the event type. The _Job_ defines what action is to be taken, expressed as using
Gateway/Dispatcher-style syntax. The _Trigger_ also contains a system-generated ID. For example:

[source,json]
----
{
    "title": "High Severity",
    "condition": {
        "eventtype_ids": ["{{eventtype_id}}"],
        "query": {
            "query": {
                "bool": {
                    "must": [
                        { "match": {"severity": 5} },
                        { "match": {"code": "PHONE"} }
                    ]
                }
            }
        }
    },
    "job": {
        "userName": "test",
        "jobType": {
            "type": "execute-service",
            "data": {
                "serviceId": "{{serviceId}}",
                "dataInputs": {},
                "dataOutput": [ { "mimeType": "application/json", "type": "text" } ]
            }
        }
    }
}
----

In this example, the job will be executed only when our "US data found" event occurs with the
specific problem being that a US bounding box has been found with a severity of 4.

NOTE: the `job.Task` field is a string that contains JSON. It can be templated and filled in with
values provided by the event data. To make a value variable, prefix it with a '$'.

NOTE: the "type" field of the "condition" will likely be removed in the future, as the query DSL
allows us to specify the event type directly within it; this would open up the possibility of
having a condition based on multiple events.


## The Event

The user may generate an _Event_ of that _EventType_ to indicate some interesting condition has
occurred. The _Event_ object is POSTed to `/event` and contains the ID of the _EventType_, the
date the event occurred, and the parameters of the event. It also contains a system-generated ID.
For example:

[source,json]
----
{
    "eventtype_id": "{{eventtype_id}}",
    "date": "2007-06-06T14:30:00Z",
    "mapping": {
        "datatype": "raster",
        "espg": 0,
        "minX": 0,
        "minY": 0,
        "maxX": 0,
        "maxY": 0,
        "hosted": true
    }
}
----


## The Alert

Whenever the condition of a _Trigger_ is met, the system will create an _Alert_ object. The user
can GET a list of alerts from `/alert`. The _Alert_ object contains the ids of the _Trigger_ that
was hit and the _Event_ which caused it. It also contains the now ubiquitous system-generated ID.
For example:

[source,json]
----
{
    "id": "8e6fa",
    "trigger_id": "987d6",
    "event_id": "53dac"
}
----

NOTE: in the future the `event_id` may become an array of event IDs.

NOTE: the `?trigger=id` and `?after=date` query params will soon be provided to make this polling
    process somewhat more palatable.
