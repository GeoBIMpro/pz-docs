# Configuration Management

Piazza defines a Configuration Management process to streamline the building, testing, and deploying of the Piazza application services. This section defines the processes that Piazza development team adheres to.

### Source Control

Piazza components are hosted in GitHub repositories at github.com/venicegeo. Each of the core components are separated into a different repository. Common projects exist for Java and Go languages, for used in other components of that languge that may depend on common calls, for example to the Piazza Logger component. Work done for specific tasks is done under branches, and when work is complete, it is generally reviewed by a peer and then merged into the master branch. Upon merging to the master branch, a Jenkins pipeline is initiazed that will build and deploy this version to an initial testing environment.

### Environments

Piazza defines multiple environments used for elevating levels of stability and readiness - from development environments up to production. This allows multiple instances of Piazza to be running at the same time, while being completely separated. Each environment is Piazza contains every core component and service, in isolation to other environments (environments do NOT talk to one another - they are completely separate). In our Cloud Foundry deployment, this is achieved by using different `stages`. 

The `int` or integration stage is what the master branch currently pushes to. This is the latest, unstable code. 
The `stage` or staging environment is considered stable and has regular integration tests being run to verify functionality. Ideally, code is elevated from `int` to `stage` when tests have fully passed on the environment in `int`.
The `prod` or production environment is pushed to from stage, manually, when the `stage` code is fully tested and functional, and when a new *version* is ready to be created. This would be accompanied by an announcement in appropriate RocketChat channel `pz-announce` and should also be paired with a series of release notes and potential breaking changes.

### Jenkins

Jenkins sets up a GitHub webhook, so that each Piazza repository in GitHub will alert Jenkins when master receives a new commit. This will then trigger the Jenkins pipeline for that repository. The pipeline for each project will 1) Compile the code 2) Stage the application 3) Deploy the application to Cloud Foundry. Cloud Foundry deployments are achieved by each project defining a *.manifest.yml file in the root directory of its repository that will contain information for the Cloud Foundry deployment. Jenkins will automatically push to `int` on any commits to master. Jenkins can also, manually, be told to push an individual project to a specific environment - or push the entire Piazza set of components to a specific environment. 

### Testing

Testing is done in two stages. First, each project contains its own set of isolated unit tests that must succeed before any build/compilation of the code succeeds. Any unit tests failed will mark the build as failure and no code will be pushed to any Cloud Foundry environment. Once the Unit Tests pass, then the application can be pushed to a Cloud Foundry environment. At this point, automated integration tests take place. These integration tests will test the Gateway API (and other internal component APIs) via REST requests. This integration test collection is handled using Postman/Newman as run through Jenkins. Any failures in the Integration tests will alert that the integrated environment is "failing" and no elevation of that environment will take place.

### Versioning

Version numbers are associated with each production environment of Piazza. Major version numbers are tied to the Sprint that the code was pushed to (at the end of) and the minor version 