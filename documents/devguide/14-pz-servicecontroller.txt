# Pz Service Controller

The Piazza Core ServiceController manages and executes web services external to the Piazza core architecture (User Services).  It provides a REST API allowing developers to perform web service management activities. Using the ServiceController, developers can:

. Register web services for search/discovery (See pz-search for details)
. Update information on the web service (e.g. URL, name, version and other metadata)
. Remove a web service from the registry
. View details about registered web services
. Execute a registered web service
. Use Piazza as a job management system for their services

The figure below shows the high level architecture of Piazza and how the ServiceController interacts with different components.

image::images/sc-architecture.png[title=“Service Controller in Piazza“]


## How to Use


### Prerequisites

The ServiceController, version 1.0, uses the following to build and run:

* http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html[Java Development Kit 1.8]
* https://maven.apache.org[Maven]
* https://www.mongodb.com/download-center[MongoDB]
* https://www.virtualbox.org/wiki/Downloads[Oracle VM VirtualBox] (for running the ServiceController on individual VMs)*
* https://www.vagrantup.com/downloads.html[Vagrant]*
* https://www.github.com/venicegeo/pz-jobcommon[pz-jobcommon]**
* https://www.github.com/venicegeo/pz-gateway[pz-gateway]**
* https://www.github.com/venicegeo/pz-jobmanager[pz-jobmanager]**

_* Software needed to use Vagrant to standup a mock Piazza Core cluster_

_**These services are part of the Piazza Core. When these services are not available, the ServiceController defaults to standalone behavior._


## Obtaining the ServiceController
The repository containing the ServiceController is hosted on GitHub at the following location: https://github.com/venicegeo/pz-servicecontroller. Clone this repository to obtain the latest copy.  The ServiceController can be built and run standalone or from within predefined virtual machines using Vagrant.


## Building the Source

Before using the ServiceController, decide whether you want to run the ServiceController with supporting Piazza Core Services and VirtualBox VMs (with MongoDB, Kafka, etc..), or if you want to run the ServiceController standalone.


### Standalone Option

To build the ServiceController, run

    mvn clean install

This will build the ServiceController and produce an executable jar which is placed in the `/target` directory.

The name of the jar will be `piazzaServiceController-(version number).BUILD-SNAPSHOT.jar`.

Once built, to run the standalone ServiceController project, run

    mvn spring-boot:run

### Vagrant

Start up a Windows PowerShell **as administrator**. Navigate to the `conf` directory. Issue the command

    vagrant up

This command will create the serviceregistry and serviceregistrydb VMs.


## Running the ServiceController
Please refer to repository readme: https://github.com/venicegeo/pz-servicecontroller

### Debugging

The ServiceController provides logging messages at an **INFO** level displaying informational messages that highlight the progress of the application at coarse-grained level.  To debug, the ServiceController, run the ServiceController specifying the _logging.level.org.venice.piazza.servicecontroller_ property as **DEBUG**

    > java -jar -Dlogging.level.org.venice.piazza.servicecontroller=DEBUG piazzaServiceController-(version number).BUILD-SNAPSHOT.jar

When the pz-logger service is available, the ServiceController uses it to log additional messages.


## Getting Started With the REST API

To become familiar with the ServiceController, use data transfer tools such as **cURL** or UI data transfer tools such as **Postman** (https://www.getpostman.com/) to interact with the ServiceController REST API.

The API and end points used for working with the ServiceController are documented in Swagger at: http://pz-swagger.venicegeo.io/#!/Service

Metadata about Piazza Core Resources are represented as _**ResourceMetadata**_ within the Piazza Core.  Please look at the ResourceMetadata model, documented as part of registering a user service, in swagger (http://pz-swagger.venicegeo.io/#!/Service/post_service) for descriptions of these metadata fields.

The following examples on registering and executing user services are the payloads for interacting directly with the ServiceController. These same payloads can also be used within registration and execution requests going through the Gateway. Refer to the Swagger API documentation and the <<_gateway_api>> section of this document to determine what additional items need to be specified.


### Registering a User Service

Before the ServiceController can manage a user service, the service has to be registered. To do this, utilize the ServiceController's _**registerService**_ service passing in Service JSON.  This JSON contains information as to the type of service (normal, asynchronous, task managed) and additional metadata such as ownership and attribution of the service.


#### Registering a User Service that uses POST with Query Parameters

Piazza user services register user services using the following endpoint: https://pz-gateway.venicegeo.io/service
Piazza developers can build and test registering user services using localhost. When running or testing the ServiceController internally, the following endpoint can be used: `https://<the-hostname-you-are-running-from>/servicecontroller/registerService`.

Below is an example of how to register a web service that uses the **POST** method, specifies the input parameters via URL key value pairs - in this case using the parameter aString. This example registers the toLower Service:

https://pz-gateway.venicegeo.io/service
[source,json]
----
{
    "url": "http://pz-servicecontroller.venicegeo.io/jumpstart/string/toLower",
    "contractUrl": "http://pz-servicecontroller.cf.venicegeo.io/toLowerContract",
    "method": "POST",
    "resourceMetadata": {
        "name": "The toLower Service",
        "description": "Service to convert string to lower case"
    }
}
----

The response from the ServiceController will be a JSON message providing the serviceId for the toLower Service.

[source,json]
----
{
    "type": "service-id",
    "serviceId": "304e4ef3-f6a0-4f91-98c3-447a4f62d0af"
}

----
_Once registered, users, should utilize the serviceId to perform any functions on the registered service._


#### Registering a User Service that uses GET without any parameters
To register a service that uses the **GET** example without URL parameters (as per a "pure" REST case), the process is the same but be sure to specify **GET** as the method.

[source,json]
----
{

    "url": "http://pz-servicecontroller.venicegeo.io//jumpstart/moviequotewelcome",
    "contractUrl": "http://pz-servicecontroller.cf.venicegeo.io/jumpstart/moviequotewelcomeContract",
    "method": "GET",
    "resourceMetadata": {
        "name": "Movie Quote Welcome",
         "description": "A web service that welcomes you to pz-servicecontroller"
    }

}
----

### Executing a Service

To execute a service, utilize the ServiceController's _**executeService**_ API.  Below is an example of how to execute the toLower service that was registered in the previous section. This is just an example, hypothetical service that returns a string response from a simple string input. 

[source,json]
----
{
    "serviceId": "{{serviceId}}",
    "dataInputs": {
        "aString": {
            "type": "urlparameter",
            "content": "The rain in Spain"
        },
        "dataOutput": [{
            "mimeType": "application/json",
            "type": "text"
        }]
    }
}
----

The response will be:

[source,json]
----
<200 OK,{"result":"it is raining today."},{Server=[Apache-Coyote/1.1], Content-Type=[application/json;charset=UTF-8], Content-Length=[33], Date=[Tue, 19 Jan 2016 13:27:33 GMT]}>
----

Executing the hypothetical _moviequotewelcome_ Service previously registered would be done as follows:

[source,json]
----
{
    "serviceId": "{{serviceId}}",
    "dataInputs": {},
    "dataOutput": [{
        "mimeType": "application/json",
        "type": "text"
    }]
}
----

The response will be:

[source,json]
----
<200 OK,{"message":"I'm Ron Burgandyyyy?
Welcome to the piazza pz-servicecontroller!
Details on using pz-servicecontrollers are located on the github venice wiki!
"},{Server=[Apache-Coyote/1.1], Content-Type=[application/json;charset=UTF-8], Content-Length=[140], Date=[Tue, 19 Jan 2016 13:31:17 GMT]}>
----

#### Executing a Service Sending JSON

To execute the convert service, do the following:

[source,json]
----
{
    "serviceId": "{{serviceId}}",
    "dataInputs": {
        "": {
            "content": "{\"theString\":\"MARGE test\", \"conversionType\":\"UPPER\"}",
            "type": "body",
            "mimeType": "application/json"
        },
        "dataOutput" : [{
            "mimeType": "application/json",
            "type": "text"
        }]
    }
}
----


### Getting Description of a User Service

To get a description of a user service registered with Piazza perform the following call:

    GET https://pz-servicecontroller.venicegeo.io/service/{{serviceId}}

The response will be the metadata associated with the specified serviceId.


### Getting a List of Registered User Services

To get a list of the user services registered with Piazza, perform the following call:

    GET https://pz-servicecontroller.venicegeo.io/service/

The response will be a service-list containing metadata for each of the registered user services.


### General Pz Service Operations

The Pz ServiceController supports other Pz Service Operations..

**GET /** on http://pz-servicecontroller.venicegeo.io
Provides a health check on Pz-ServiceController.
If the Pz-ServiceController is running you should see the following response:

....
Welcome from the Piazza Service Controller.
For details on running and using the ServiceController,
see Pz Service Controller for details.
....

**GET /admin/stats** on http://pz-servicecontroller.venicegeo.io
Provides statistics on the Pz-ServiceController.

[source,json]
----
{
    "classes": 11529,
    "classes.loaded": 11529,
    "classes.unloaded": 0,
    "counter.status.200.root": 1,
    "counter.status.302.admin.stats": 1,
    "gauge.response.admin.stats": 7.0,
    "gauge.response.root": 102.0,
    "gc.ps_marksweep.count": 0,
    "gc.ps_marksweep.time": 0,
    "gc.ps_scavenge.count": 4900,
    "gc.ps_scavenge.time": 13789,
    "heap": 382464,
    "heap.committed": 382464,
    "heap.init": 382976,
    "heap.used": 222650,
    "httpsessions.active": 0,
    "httpsessions.max": -1,
    "instance.uptime": 18151962,
    "mem": 382464,
    "mem.free": 159813,
    "processors": 2,
    "systemload.average": 1.05,
    "threads": 31,
    "threads.daemon": 27,
    "threads.peak": 31,
    "threads.totalStarted": 37,
    "uptime": 18166991
}
----

// vim: set syntax=asciidoc wrap:

### Service Registration Types

There are three types of services, to support a variety of different workflows for existing REST services. The type of a Service is specified during registration of the Service. 

To external users who are merely interacting with Services by executing them, these different types are entirely transparent. The differences only lie in the underlying execution of that Service.

For detailed explanations on any of these Service Types, please see the Users Guide on Services.

The first type is the 'standard' type of Service registration. To specify this type, no additional parameters must be added to the registration payload - it is the default type. This will register a URL endpoint (and a method) that will be called whenever the user executes the Service through the Gateway. ServiceController will contact the service directly with the specified parameters and then store the result that is returned from the Service. This is the most simple form of execution.

The second type is the 'asynchronous' type. This can be specified by saying `isAsynchronous: true` in the service Registration payload. This type handles cases where the external Service has some sort of internal job queueing mechanism that can be used in order to defend against a large amount of requests being sent to the server that could potentially overwhelm and crash the server. Using this type of Registration, the ServiceController will contact the Service initially with the inputs for an execution. That request is expected to immediately return with a unique Job ID (provided by the Service). ServiceController will then periodically query the Service for status on that particular job. When the Status is reported back as Success, then the ServiceController will make an additional request to acquire the results and store them in Piazza.

The last type is the 'taskManaged' type. This is specified by saying 'isTaskManaged: true' in the service Registration payload. This is designed to support the case where an existing Service has no job management system, or any way to defend against large amounts of requests. Using this Task Managed case, Service Executions will be placed in a Jobs Queue for that particular Service - no external request is made to the Service. Instead, the Service polls Piazza for Jobs in its queue for that Service. In this way, the Service is able to retrieve work only when it is able to handle it. Piazza performs the role of load balancing and job queueing for this Service. When results for a particular job are completed, then the external service sends those results directly back to Piazza. 